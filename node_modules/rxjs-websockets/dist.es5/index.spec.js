"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var testing_1 = require("rxjs/testing");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var _1 = require(".");
describe('rxjs-websockets', function () {
    /* eslint-disable @typescript-eslint/no-empty-function */
    var scheduler;
    var expect$;
    var flush;
    var cold;
    var hot;
    beforeEach(function () {
        scheduler = new testing_1.TestScheduler(function (x, y) {
            expect(x).toEqual(y);
        });
        expect$ = scheduler.expectObservable.bind(scheduler);
        flush = scheduler.flush.bind(scheduler);
        cold = scheduler.createColdObservable.bind(scheduler);
        hot = scheduler.createHotObservable.bind(scheduler);
    });
    var MockSocket = /** @class */ (function () {
        function MockSocket() {
            this.onmessage = function (event) { };
            this.onopen = function (event) { };
            this.onclose = function (event) { };
            this.onerror = function (event) { };
            this.close = jest.fn();
        }
        // forwards input as output
        MockSocket.prototype.send = function (data) {
            this.onmessage({ data: data });
        };
        return MockSocket;
    }());
    var connectHelper = function (mockSocket, protocols) {
        if (protocols === void 0) { protocols = []; }
        return _1.default('url', { protocols: protocols, makeWebSocket: function () { return mockSocket; } });
    };
    it('connects to websocket lazily and retrieves data', function () {
        var mockSocket = new MockSocket();
        var socket = connectHelper(mockSocket);
        var input = hot('abcde|');
        expect$(rxjs_1.of(null).pipe(
        // delay subscription to websocket by 10ms, TODO: find some way to
        // verify the connection is attempted lazily
        operators_1.delay(10, scheduler), operators_1.switchMap(function () {
            return socket.pipe(operators_1.switchMap(function (factory) {
                // ensure factory is called when socket is open
                expect(scheduler.now()).toEqual(20);
                return factory(input);
            }));
        }))).toBe('--cde');
        // websocket opens at 20ms
        scheduler.schedule(function () {
            // if one of the expectations raises an error this won't be defined
            if (mockSocket.onopen)
                mockSocket.onopen({});
        }, 20);
        flush();
    });
    it('closes websocket on unsubscribe', function () {
        var mockSocket = new MockSocket();
        var socket = connectHelper(mockSocket);
        scheduler.schedule(function () { return mockSocket.onopen({}); }, 10);
        expect$(socket.pipe(operators_1.switchMap(function (factory) { return factory(cold('a|')); })), '--!').toBe('-a');
        flush();
        expect(mockSocket.close).toHaveBeenCalledTimes(1);
    });
    describe('raises Error', function () {
        var runTest = function (reason, code, expectedReason) {
            var mockSocket = new MockSocket();
            var socket = connectHelper(mockSocket);
            scheduler.schedule(function () { return mockSocket.onopen({}); }, 10);
            scheduler.schedule(function () { return mockSocket.onclose({ reason: reason, code: code }); }, 30);
            expect$(socket.pipe(operators_1.switchMap(function (factory) { return factory(cold('a')); }), 
            // rethrow error as string... can't get expectation to match the error
            operators_1.catchError(function (error) { return rxjs_1.throwError(error.message); }))).toBe('-a-#', undefined, expectedReason);
            flush();
        };
        it('with message equal to reason on unclean websocket close', function () {
            var reason = 'Freakish closure';
            runTest(reason, 9000, reason);
        });
        it('with normalClosureMessage when socket was closed normally', function () {
            runTest('whatever', 1000, _1.normalClosureMessage);
        });
    });
});
//# sourceMappingURL=index.spec.js.map