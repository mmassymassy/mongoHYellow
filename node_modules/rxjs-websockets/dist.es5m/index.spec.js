import { TestScheduler } from 'rxjs/testing';
import { of, throwError } from 'rxjs';
import { delay, catchError, switchMap } from 'rxjs/operators';
import connect, { normalClosureMessage } from '.';
describe('rxjs-websockets', function () {
    /* eslint-disable @typescript-eslint/no-empty-function */
    var scheduler;
    var expect$;
    var flush;
    var cold;
    var hot;
    beforeEach(function () {
        scheduler = new TestScheduler(function (x, y) {
            expect(x).toEqual(y);
        });
        expect$ = scheduler.expectObservable.bind(scheduler);
        flush = scheduler.flush.bind(scheduler);
        cold = scheduler.createColdObservable.bind(scheduler);
        hot = scheduler.createHotObservable.bind(scheduler);
    });
    var MockSocket = /** @class */ (function () {
        function MockSocket() {
            this.onmessage = function (event) { };
            this.onopen = function (event) { };
            this.onclose = function (event) { };
            this.onerror = function (event) { };
            this.close = jest.fn();
        }
        // forwards input as output
        MockSocket.prototype.send = function (data) {
            this.onmessage({ data: data });
        };
        return MockSocket;
    }());
    var connectHelper = function (mockSocket, protocols) {
        if (protocols === void 0) { protocols = []; }
        return connect('url', { protocols: protocols, makeWebSocket: function () { return mockSocket; } });
    };
    it('connects to websocket lazily and retrieves data', function () {
        var mockSocket = new MockSocket();
        var socket = connectHelper(mockSocket);
        var input = hot('abcde|');
        expect$(of(null).pipe(
        // delay subscription to websocket by 10ms, TODO: find some way to
        // verify the connection is attempted lazily
        delay(10, scheduler), switchMap(function () {
            return socket.pipe(switchMap(function (factory) {
                // ensure factory is called when socket is open
                expect(scheduler.now()).toEqual(20);
                return factory(input);
            }));
        }))).toBe('--cde');
        // websocket opens at 20ms
        scheduler.schedule(function () {
            // if one of the expectations raises an error this won't be defined
            if (mockSocket.onopen)
                mockSocket.onopen({});
        }, 20);
        flush();
    });
    it('closes websocket on unsubscribe', function () {
        var mockSocket = new MockSocket();
        var socket = connectHelper(mockSocket);
        scheduler.schedule(function () { return mockSocket.onopen({}); }, 10);
        expect$(socket.pipe(switchMap(function (factory) { return factory(cold('a|')); })), '--!').toBe('-a');
        flush();
        expect(mockSocket.close).toHaveBeenCalledTimes(1);
    });
    describe('raises Error', function () {
        var runTest = function (reason, code, expectedReason) {
            var mockSocket = new MockSocket();
            var socket = connectHelper(mockSocket);
            scheduler.schedule(function () { return mockSocket.onopen({}); }, 10);
            scheduler.schedule(function () { return mockSocket.onclose({ reason: reason, code: code }); }, 30);
            expect$(socket.pipe(switchMap(function (factory) { return factory(cold('a')); }), 
            // rethrow error as string... can't get expectation to match the error
            catchError(function (error) { return throwError(error.message); }))).toBe('-a-#', undefined, expectedReason);
            flush();
        };
        it('with message equal to reason on unclean websocket close', function () {
            var reason = 'Freakish closure';
            runTest(reason, 9000, reason);
        });
        it('with normalClosureMessage when socket was closed normally', function () {
            runTest('whatever', 1000, normalClosureMessage);
        });
    });
});
//# sourceMappingURL=index.spec.js.map